# üéµ Aplicaci√≥n Vinilos

Una aplicaci√≥n m√≥vil para gestionar y explorar discos de vinilo, construida siguiendo pr√°cticas modernas de desarrollo Android.

---

## üõ†Ô∏è Arquitectura

La aplicaci√≥n implementa el patr√≥n **MVVM** (Model-View-ViewModel) y principios de **Clean Architecture**, proporcionando una clara separaci√≥n de responsabilidades y facilitando la mantenibilidad y el testeo.

---

## üì¶ Estructura y Componentes del Proyecto

### Capa de Datos

1. **Modelos**
   - Ubicados en `app/src/main/java/com/uniandes/vinilos/models/`
   - Definen las estructuras de datos utilizadas en la aplicaci√≥n
   - Ejemplo:
   ```kotlin
   data class Album(
       val id: Int,
       val name: String,
       val cover: String,
       val releaseDate: String,
       val description: String,
       val genre: String,
       val recordLabel: String,
       val tracks: List<Track>,
       val comments: List<Comment>,
       val performers: List<Performer>
   )
   ```

2. **DAOs (Objetos de Acceso a Datos)**
   - Ubicados en `app/src/main/java/com/uniandes/vinilos/data/dao/`
   - Definen interfaces para operaciones de datos
   - Implementados por DAOs de API que utilizan Retrofit
   - Ejemplo:
   ```kotlin
   interface AlbumDao {
       suspend fun getAllAlbums(): List<Album>
       suspend fun getAlbumById(id: Int): Album?
       suspend fun getAlbumTracks(albumId: Int): List<Track>
   }

   @ActivityRetainedScoped
   class ApiAlbumDao @Inject constructor(
       private val albumService: AlbumService
   ) : AlbumDao {
       override suspend fun getAllAlbums(): List<Album> {
           return try {
               val response = albumService.getAlbums()
               if (response.isSuccessful) {
                   response.body() ?: emptyList()
               } else {
                   emptyList()
               }
           } catch (e: Exception) {
               emptyList()
           }
       }
   }
   ```

3. **Servicios de Red**
   - Ubicados en `app/src/main/java/com/uniandes/vinilos/network/`
   - Definen endpoints de API usando Retrofit
   - Ejemplo:
   ```kotlin
   interface AlbumService {
       @GET("albums")
       suspend fun getAlbums(): Response<List<Album>>

       @GET("albums/{id}")
       suspend fun getAlbum(@Path("id") id: Int): Response<Album>

       @GET("albums/{id}/tracks")
       suspend fun getAlbumTracks(@Path("id") id: Int): Response<List<Track>>
   }
   ```

4. **Repositorios**
   - Ubicados en `app/src/main/java/com/uniandes/vinilos/data/repository/`
   - Act√∫an como fuente √∫nica de verdad para los datos
   - Utilizan DAOs para obtener datos de la red
   - Ejemplo:
   ```kotlin
   @Singleton
   class AlbumRepository @Inject constructor(
       private val albumDao: AlbumDao
   ) {
       suspend fun getAllAlbums(): List<Album> {
           return albumDao.getAllAlbums()
       }

       suspend fun getAlbumById(id: Int): Album? {
           return albumDao.getAlbumById(id)
       }

       suspend fun getAlbumTracks(albumId: Int): List<Track> {
           return albumDao.getAlbumTracks(albumId)
       }
   }
   ```

#### Inyecci√≥n de Dependencias
- Utiliza Hilt para la inyecci√≥n de dependencias
- Configuraci√≥n de red en `NetworkModule.kt`:
```kotlin
@Module
@InstallIn(SingletonComponent::class)
object NetworkModule {
    private const val BASE_URL = "http://146.190.65.12:3000/"

    @Provides
    @Singleton
    fun provideRetrofit(okHttpClient: OkHttpClient): Retrofit {
        return Retrofit.Builder()
            .baseUrl(BASE_URL)
            .client(okHttpClient)
            .addConverterFactory(GsonConverterFactory.create())
            .build()
    }

    @Provides
    @Singleton
    fun provideAlbumService(retrofit: Retrofit): AlbumService {
        return retrofit.create(AlbumService::class.java)
    }
}
```

---

### Capa de UI

1. **Fragments**
   - Ubicados en `app/src/main/java/com/uniandes/vinilos/ui/fragments/`
   - Manejan el renderizado de UI y las interacciones del usuario
   - Ejemplo:
   ```kotlin
   class AlbumListFragment : Fragment() {
       private val viewModel: AlbumViewModel by viewModels()
       private lateinit var binding: FragmentAlbumListBinding
       
       override fun onCreateView(
           inflater: LayoutInflater,
           container: ViewGroup?,
           savedInstanceState: Bundle?
       ): View {
           binding = FragmentAlbumListBinding.inflate(inflater, container, false)
           return binding.root
       }
       
       override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
           super.onViewCreated(view, savedInstanceState)
           setupRecyclerView()
           observeViewModel()
       }
   }
   ```

2. **ViewModels**
   - Ubicados en `app/src/main/java/com/uniandes/vinilos/ui/viewmodel/`
   - Manejan la l√≥gica de negocio y la transformaci√≥n de datos
   - Ejemplo:
   ```kotlin
   class AlbumViewModel @Inject constructor(
       private val albumRepository: AlbumRepository
   ) : ViewModel() {
       private val _albums = MutableStateFlow<List<Album>>(emptyList())
       val albums: StateFlow<List<Album>> = _albums.asStateFlow()
       
       fun loadAlbums() {
           viewModelScope.launch {
               albumRepository.getAlbums().collect { albums ->
                   _albums.value = albums
               }
           }
       }
   }
   ```

### Implementaci√≥n de Navegaci√≥n

La aplicaci√≥n utiliza el Navigation Component con una arquitectura de actividad √∫nica:

1. **Grafo de Navegaci√≥n**
   - Ubicado en `app/src/main/res/navigation/nav_graph.xml`
   - Define todos los posibles caminos de navegaci√≥n
   ```xml
   <navigation xmlns:android="http://schemas.android.com/apk/res/android"
       xmlns:app="http://schemas.android.com/apk/res-auto"
       android:id="@+id/nav_graph"
       app:startDestination="@id/roleSelectionFragment">
       
       <fragment
           android:id="@+id/roleSelectionFragment"
           android:name="com.uniandes.vinilos.ui.fragments.RoleSelectionFragment"
           android:label="Seleccionar Rol">
           <action
               android:id="@+id/action_roleSelection_to_albumList"
               app:destination="@id/albumListFragment" />
       </fragment>
       
       <fragment
           android:id="@+id/albumListFragment"
           android:name="com.uniandes.vinilos.ui.fragments.AlbumListFragment"
           android:label="√Ålbumes">
           <action
               android:id="@+id/action_albumList_to_albumDetail"
               app:destination="@id/albumDetailFragment" />
       </fragment>
   </navigation>
   ```

2. **Navegaci√≥n en Fragments**
   ```kotlin
   // Navegar al detalle del √°lbum
   findNavController().navigate(
       AlbumListFragmentDirections.actionAlbumListToAlbumDetail(albumId)
   )
   
   // Navegar hacia atr√°s
   findNavController().navigateUp()
   ```

3. **Safe Args**
   - Utilizado para navegaci√≥n con tipos seguros
   - Generado por el Navigation Component
   - Ejemplo:
   ```kotlin
   // En AlbumListFragment
   val action = AlbumListFragmentDirections
       .actionAlbumListToAlbumDetail(albumId)
   findNavController().navigate(action)
   
   // En AlbumDetailFragment
   val albumId = arguments?.let { 
       AlbumDetailFragmentArgs.fromBundle(it).albumId 
   }
   ```

## Pruebas

La aplicaci√≥n utiliza pruebas instrumentadas con Espresso para verificar la funcionalidad de la UI.

### Estructura de Pruebas

Las pruebas se encuentran en:
- `app/src/androidTest/java/com/uniandes/vinilos/ui/albums/`
- Utilizan Espresso para pruebas de UI
- Se enfocan en la interacci√≥n con la interfaz de usuario

### Ejemplo de Prueba con Espresso

```kotlin
@HiltAndroidTest
class AlbumListFragmentTest {
    @Test
    fun testAlbumListFragment_UIElements() {
        // Configuraci√≥n
        onView(withId(R.id.visitorRole)).perform(click())
        onView(withId(R.id.continueButton)).perform(click())
        
        // Verificaci√≥n
        onView(withId(R.id.albumsRecyclerView))
            .check(matches(isDisplayed()))
    }

    @Test
    fun testAlbumDetailFragment_BasicInfo() {
        // Verificar que todos los elementos b√°sicos de informaci√≥n se muestran
        onView(withId(R.id.albumCoverImageView))
            .check(matches(isDisplayed()))
        onView(withId(R.id.albumTitleTextView))
            .check(matches(isDisplayed()))
        onView(withId(R.id.albumArtistTextView))
            .check(matches(isDisplayed()))
        onView(withId(R.id.albumGenreTextView))
            .check(matches(isDisplayed()))
        onView(withId(R.id.albumReleaseDateTextView))
            .check(matches(isDisplayed()))
        onView(withId(R.id.albumDescriptionTextView))
            .check(matches(isDisplayed()))
    }

    @Test
    fun testAlbumDetailFragment_TracksList() {
        // Verificar que el RecyclerView de tracks se muestra
        onView(withId(R.id.tracksRecyclerView))
            .check(matches(isDisplayed()))
            .check(matches(hasMinimumChildCount(1)))
    }

    @Test
    fun testAlbumDetailFragment_PerformersList() {
        // Verificar que el RecyclerView de performers se muestra
        onView(withId(R.id.performersRecyclerView))
            .check(matches(isDisplayed()))
            .check(matches(hasMinimumChildCount(1)))
    }
}
```

### Ejecuci√≥n de Pruebas

Hay dos formas de ejecutar las pruebas:

1. **A trav√©s de la l√≠nea de comandos:**
   ```bash
   ./gradlew connectedAndroidTest
   ```

2. **A trav√©s de Android Studio:**
   - Abrir el archivo de prueba
   - Hacer clic derecho sobre el archivo o m√©todo de prueba
   - Seleccionar "Run 'NombreDelTest'"
   - Tambi√©n se pueden ejecutar pruebas individuales haciendo clic en el √≠cono de "play" junto al m√©todo de prueba

Las pruebas verifican:
1. Visualizaci√≥n correcta de elementos UI
2. Interacci√≥n con botones y controles
3. Navegaci√≥n entre pantallas
4. Carga y visualizaci√≥n de datos
5. Comportamiento de listas y RecyclerViews

## Construcci√≥n de la Aplicaci√≥n

### Generaci√≥n de APK

1. **APK de Depuraci√≥n**
   ```bash
   ./gradlew assembleDebug
   ```
   Salida: `app/build/outputs/apk/debug/app-debug.apk`

2. **APK de Lanzamiento**
   ```bash
   ./gradlew assembleRelease
   ```
   Salida: `app/build/outputs/apk/release/app-release.apk`


## üìö Dependencias

La aplicaci√≥n utiliza varias bibliotecas modernas de Android:

- **Hilt**: Inyecci√≥n de dependencias
- **Retrofit**: Llamadas de red
- **Coroutines**: Programaci√≥n as√≠ncrona
- **Flow**: Flujos reactivos
- **Navigation Component**: Manejo de navegaci√≥n
- **ViewBinding**: Vinculaci√≥n de vistas
- **Material Design**: Componentes de UI

---

## Estructura del Proyecto

```
app/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ main/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ java/com/uniandes/vinilos/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ models/          # Modelos de datos
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ network/         # Servicios de API
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ repository/      # Repositorios de datos
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ui/             # Componentes de UI
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ fragments/   # Fragments
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ viewmodel/   # ViewModels
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ utils/          # Clases de utilidad
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ res/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ layout/         # Archivos de layout
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ navigation/     # Grafos de navegaci√≥n
‚îÇ   ‚îú‚îÄ‚îÄ test/                   # Pruebas unitarias
‚îÇ   ‚îî‚îÄ‚îÄ androidTest/            # Pruebas instrumentadas
```

---

## Buenas Pr√°cticas para el Consumo de Memoria

### Perfilamiento y Monitoreo

- Se utiliz√≥ el **Android Studio Profiler** para monitorear el consumo de memoria de la aplicaci√≥n durante los principales flujos de uso (navegaci√≥n entre pantallas, carga de datos, etc.).
- No se detectaron fugas de memoria durante las pruebas.
- Se realizaron capturas de pantalla del profiler como evidencia del monitoreo (ver im√°genes abajo).

### Microoptimizaciones implementadas

A continuaci√≥n se detallan las microoptimizaciones aplicadas en la aplicaci√≥n para mejorar el rendimiento y la eficiencia, junto con ejemplos de c√≥digo y referencias a los archivos donde se implementan:

- **Uso de ViewHolder en RecyclerView:**
  - Se implementa el patr√≥n ViewHolder para evitar inflar vistas innecesariamente y mejorar el rendimiento de las listas.
  - **Ejemplo:**
    ```kotlin
    class AlbumAdapter(private val albums: List<Album>) : RecyclerView.Adapter<AlbumAdapter.AlbumViewHolder>() {
        class AlbumViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {
            // ...
        }
        // ...
    }
    ```
  - **Archivo:** `app/src/main/java/com/uniandes/vinilos/ui/adapters/AlbumAdapter.kt`

- **Carga eficiente de im√°genes con Glide:**
  - Glide gestiona la memoria y el cach√© de im√°genes, evitando cargas redundantes y liberando recursos autom√°ticamente.
  - **Ejemplo:**
    ```kotlin
    Glide.with(context)
        .load(album.cover)
        .placeholder(R.drawable.placeholder)
        .into(binding.albumCoverImageView)
    ```
  - **Archivo:** `app/src/main/java/com/uniandes/vinilos/ui/adapters/AlbumAdapter.kt`

- **Uso de corutinas para operaciones as√≠ncronas:**
  - Las operaciones de red y de base de datos se realizan fuera del hilo principal, evitando bloqueos de la interfaz de usuario.
  - **Ejemplo:**
    ```kotlin
    viewModelScope.launch {
        val albums = albumRepository.getAllAlbums()
        _albums.value = albums
    }
    ```
  - **Archivo:** `app/src/main/java/com/uniandes/vinilos/ui/viewmodel/AlbumViewModel.kt`

- **Liberaci√≥n de recursos en onDestroy/onCleared:**
  - Se liberan recursos y referencias en los m√©todos adecuados para evitar fugas de memoria.
  - **Ejemplo:**
    ```kotlin
    override fun onCleared() {
        super.onCleared()
        // Liberar recursos si es necesario
    }
    ```
  - **Archivo:** `app/src/main/java/com/uniandes/vinilos/ui/viewmodel/AlbumViewModel.kt`

- **Uso de LiveData y ViewModel:**
  - Permite que la UI observe los datos de forma eficiente y reactiva, evitando recargas innecesarias y fugas de memoria.
  - **Ejemplo:**
    ```kotlin
    val albums: LiveData<List<Album>> = _albums
    ```
  - **Archivo:** `app/src/main/java/com/uniandes/vinilos/ui/viewmodel/AlbumViewModel.kt`

- **Reutilizaci√≥n de layouts y vistas:**
  - Se reutilizan layouts y vistas en listas para minimizar el consumo de memoria.
  - **Ejemplo:**
    ```kotlin
    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): AlbumViewHolder {
        val view = LayoutInflater.from(parent.context).inflate(R.layout.item_album, parent, false)
        return AlbumViewHolder(view)
    }
    ```
  - **Archivo:** `app/src/main/java/com/uniandes/vinilos/ui/adapters/AlbumAdapter.kt`

### Evidencia de Perfilamiento de Memoria y CPU

A continuaci√≥n se presentan capturas de pantalla del profiler de Android Studio durante la ejecuci√≥n de la aplicaci√≥n:

#### Perfilamiento de Memoria y CPU

Se realiz√≥ un an√°lisis de rendimiento utilizando **Android Studio Profiler** para evaluar el uso de CPU y memoria de la aplicaci√≥n durante una sesi√≥n t√≠pica de uso. Los resultados obtenidos son los siguientes:

#### Resultados

- **CPU:**
  - El uso del procesador se mantuvo estable y en niveles bajos (por debajo del 50% la mayor parte del tiempo).
  - La cantidad de hilos activos fue razonable (entre 40 y 52), lo cual es normal para una aplicaci√≥n Android moderna.
  - No se observaron picos ni ca√≠das bruscas que indiquen problemas de rendimiento o bloqueos.

- **Memoria:**
  - El consumo de memoria aument√≥ de manera gradual, como es esperado cuando la aplicaci√≥n carga datos y elementos de la interfaz.
  - No se detectaron picos ni ca√≠das repentinas en el uso de memoria, lo que sugiere que no hay fugas de memoria ni asignaciones excesivas.
  - El uso total de memoria se mantuvo muy por debajo de los 128 MB, lo cual es excelente para una aplicaci√≥n Android.

- **Conclusi√≥n:**
  - Los resultados muestran que la aplicaci√≥n tiene un buen desempe√±o en cuanto a uso de CPU y memoria.
  - No se identificaron problemas evidentes de rendimiento ni de gesti√≥n de memoria durante la sesi√≥n de prueba.

#### Capturas de pantalla

 ![Evidencia de uso de CPU](docs/screenshots/cpu_profiler.png)
![Evidencia de uso de memoria](docs/screenshots/ram_profiler.png)

### Buenas pr√°cticas para evitar ANRs (Application Not Responding)

Para garantizar una experiencia fluida y evitar bloqueos de la aplicaci√≥n (ANRs), se han implementado las siguientes buenas pr√°cticas en el desarrollo de la app:

- **Operaciones pesadas fuera del hilo principal (UI thread):**
  - Todas las operaciones de red y acceso a base de datos se realizan utilizando corutinas, evitando as√≠ bloquear la interfaz de usuario.
  - **Ejemplo:**
    ```kotlin
    viewModelScope.launch {
        val albums = albumRepository.getAllAlbums()
        _albums.value = albums
    }
    ```
  - **Archivo:** `app/src/main/java/com/uniandes/vinilos/ui/viewmodel/AlbumViewModel.kt`

- **Carga as√≠ncrona de im√°genes:**
  - Se utiliza Glide para cargar im√°genes de manera eficiente y as√≠ncrona, evitando bloqueos en la UI.
  - **Ejemplo:**
    ```kotlin
    Glide.with(context)
        .load(album.cover)
        .placeholder(R.drawable.placeholder)
        .into(binding.albumCoverImageView)
    ```
  - **Archivo:** `app/src/main/java/com/uniandes/vinilos/ui/adapters/AlbumAdapter.kt`

- **Uso de LiveData y ViewModel:**
  - Los datos observados por la UI se gestionan de forma reactiva, evitando operaciones innecesarias y bloqueos en el hilo principal.
  - **Ejemplo:**
    ```kotlin
    val albums: LiveData<List<Album>> = _albums
    ```
  - **Archivo:** `app/src/main/java/com/uniandes/vinilos/ui/viewmodel/AlbumViewModel.kt`

- **Evitar bucles o c√°lculos intensivos en la UI:**
  - Todas las operaciones de procesamiento intensivo se delegan a corutinas o hilos secundarios.

- **Manejo adecuado del ciclo de vida:**
  - Se utilizan ViewModel y LiveData para asegurar que las operaciones se cancelen o pausen cuando la UI no est√° visible, evitando bloqueos innecesarios.

Estas pr√°cticas aseguran que la aplicaci√≥n sea responsiva y que no se presenten ANRs durante su uso normal.